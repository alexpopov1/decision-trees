

#ifndef _TREE_
#define _TREE_


#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <iostream>
#include <stdexcept>
#include <iomanip>       // std::setw(...)
#include <cmath>         // log(...)
#include <algorithm>     // std::stable_sort(...)
#include <numeric>       // std::iota(...);
#include <limits>        // std::numeric_limits<double>::infinity();
#include <iterator>





template<typename T>
void print(T v)
{
	for (const auto& i : v)
		std::cout << i << ' ';
	std::cout << '\n';
}




template<typename T, typename U>
class TreeData
{
	
	// MEMBER OBJECTS
	
	// Vector of training example inputs, where each example is a vector
	std::vector< std::vector<T> > data;
	
	// Vector of output data corresponding to example inputs
	std::vector<U> outputs;
	
	// Indices of examples, sorted along each dimension. Consecutive examples are grouped
	// in the same vector if they have the same value in the given dimension.
	std::vector< std::map< std::size_t, std::set< std::size_t> > > indices;
	
	// Vector indicating sorted position of each data point with respect to each dimension
	std::vector< std::vector<std::size_t> > pntLocator;
	
	// Vector of all unique classes to which an input can be classified
	std::vector<U> classes;  
	
	// Maps classes to number of occurrences in training set
	std::unordered_map<U, int> tally;
	
	// All possible splits along each dimension
	std::vector< std::vector<double> > splits;
	
	// D = # dimensions, N = #examples, K = #classes
	std::size_t D, N, K;              
	
	
	




	// METHODS

	// Sort a vector and returns the new order of the original indices
	std::vector<std::size_t> sortIndices(const std::vector<T>& v)
	{
		std::vector<std::size_t> idx(v.size());
		std::iota(idx.begin(), idx.end(), 0);
		std::stable_sort(idx.begin(), idx.end(),
			[&v](std::size_t i1, std::size_t i2) {return v[i1] < v[i2];});
		return idx;
	}
	
	
	
	// Transpose a vector of vectors (similar to matrix transpose)
	std::vector< std::vector<T> > transposeData()
	{
		std::vector< std::vector<T> > v(D);
		for (std::size_t d = 0; d < D; ++d)
		{
			v[d].resize(N);
			for (std::size_t n = 0; n < N; ++n)
				v[d][n] = data[n][d];
		}
		return v;
	}
	
	
	
	// Find all unique classes, and counts the number of instances of each
	void findClasses()
	{
		for (const U& o : outputs)
			++tally[o];
		for (auto const& m : tally)
			classes.push_back(m.first);
		K = classes.size();
	}
	
	
	
	
	// Create member object 'indices'
	void indicesTable()
	{
		std::vector< std::vector<std::size_t> > idx(D);
		std::vector< std::vector<T> > transpose = transposeData();
		indices.resize(D);
		
		for (std::size_t d = 0; d < D; ++d)
		{
			idx[d] = sortIndices(transpose[d]);
			indices[d][0] = std::set<std::size_t>{idx[d][0]};
			
			std::size_t s = 0;
			for (std::size_t n = 1; n < N; ++n)
				if (data[idx[d][n]][d] == data[ idx[d][n-1] ][d])
					indices[d][s].insert(idx[d][n]);
				else
					indices[d][++s] = std::set<std::size_t>{idx[d][n]};
		}
	}	
	
	
	void locatePnts()
	{
		pntLocator.resize(D);
		for (std::size_t d = 0; d < D; ++d)
		{
			pntLocator[d].resize(N);
			for (const auto& set : indices[d])
				for (const std::size_t& pnt : set.second)
					pntLocator[d][pnt] = set.first;
			print< std::vector<std::size_t> >(pntLocator[d]);
		}
	}

	
	// Create all possible splits between N data points in D dimensions
	void createSplits()	
	{	
		splits.resize(D);
		for (std::size_t d = 0; d < D; ++d)
		{
			splits[d].resize(indices[d].size()-1);
			for (std::size_t s = 0; s < indices[d].size()-1; ++s)
				splits[d][s] = ((double)data[ *(indices[d][s].begin()) ][d]
									  + data[ *(indices[d][s+1].begin()) ][d]) / 2;

			print< std::vector<double> >(splits[d]);
		}
	}
	
	
	
	
	// Create map between classes and number of new output occurrences when moving along one split
	std::unordered_map<U, int> countMap(std::size_t d, 
			const std::map<std::size_t, std::set< std::size_t> >::iterator& it)
	{
		std::unordered_map<U, int> count;
		for (const std::size_t& i : it->second)
			++count[ outputs[i] ];
		return count;
	}
	
	
	
	
	// Initialise probabilities in first split for a given dimension
	void initialFracs(std::unordered_map< U, std::pair<int, int> >& lf, 
				std::unordered_map< U, std::pair<int, int> >& rf, const std::size_t& d)
	{		
		std::unordered_map<U, int> count = countMap(d, indices[d].begin());
		for (const U& c : classes)
		{
			const auto& search = count.find(c);
			if (search != count.end())
			{
				lf[c] = std::make_pair( count[c], ((indices[d].begin())->second).size() );
				rf[c] = std::make_pair( tally[c] - count[c], N - ((indices[d].begin())->second).size() );
			}
			else
			{
				lf[c] = std::make_pair( 0, ((indices[d].begin())->second).size() );
				rf[c] = std::make_pair( tally[c], N - ((indices[d].begin())->second).size() );
			}
		}
	}
	
	
	// Update fraction probabilites between successive splits along a given dimension
	void updateFracs(std::unordered_map< U, std::pair<int, int> >& lf, 
				std::unordered_map< U, std::pair<int, int> >& rf, std::size_t d,
				const std::map<std::size_t, std::set< std::size_t> >::iterator& it)	
	{
		std::unordered_map<U, int> count = countMap(d, it);
		for (const U& c : classes)
		{
			lf[c].second += (it->second).size();
			rf[c].second -= (it->second).size();
			
			auto search = count.find(c);
			if (search != count.end())
			{
				lf[c].first += count[c];
				rf[c].first -= count[c];
			}
		}
	}
	
	
	// Convert numerator-denominator pair into decimal
	double fracToDec(const std::pair<int, int>& fr)
	{
		return (double) fr.first / fr.second;
	}
	
	
	// Calculate self-information for a given probability
	double selfInfo(const double& p)
	{
		if (p == 0)
			return 0;
		return -log(p); 
	}
	
	
	// Calculate weighted average entropy for a given split
	double weightedEntropy(std::unordered_map< U, std::pair<int, int> > lf, 
				std::unordered_map< U, std::pair<int, int> > rf)
	{
		double lH = 0, rH = 0;
		double lWght = (double)lf[ classes[0] ].second / N;
		double rWght = (double)rf[ classes[0] ].second / N;
		
		for (const U& c : classes)
		{
			lH += fracToDec(lf[c]) * selfInfo(fracToDec(lf[c]));
			rH += fracToDec(rf[c]) * selfInfo(fracToDec(rf[c]));
		}
		
		return lWght * lH + rWght * rH;
	}



	// Compare current value to minimum and reassign minimum value and location if necessary
	void compare(const double& current, double& minVal, 
				std::pair<int, int>& min, const std::size_t& d, 
				const std::map<std::size_t, std::set< std::size_t> >::iterator& it)
	{
		std::cout << "AE(" << d << ", " << it->first << ") = " << current << '\n';
		if (current < minVal)
		{
			minVal = current;
			min.first = d; 
			min.second = it->first;
		}
	}



	// Along each dimension, calculate weighted average entropy of each split
	std::pair<int, int> chooseSplit()
	{
		std::unordered_map< U, std::pair<int, int> > lfracs, rfracs;         
		double current, minVal = std::numeric_limits<double>::infinity();
		std::pair<int, int> min = std::make_pair(-1, -1);
		
		for (std::size_t d = 0; d < D; ++d)
		{
			initialFracs(lfracs, rfracs, d);
			
			for (const U& c : classes)
			{
				std::cout << "(" << d << ", " << (indices[d].begin())->first << "): L(" << c << ") = " << lfracs[c].first << "/" << lfracs[c].second
						<< ", R(" << c << ") = " << rfracs[c].first << "/" << rfracs[c].second << "      ";
			}
			std::cout << '\n';
							
				
			current = weightedEntropy(lfracs, rfracs);
			compare(current, minVal, min, d, indices[d].begin());

			
			for (auto it = ++indices[d].begin();
						it != --indices[d].end(); ++it)
			{
				updateFracs(lfracs, rfracs, d, it);
				for (const U& c : classes)
				{
					std::cout << "(" << d << ", " << it->first << "): L(" << c << ") = " << lfracs[c].first << "/" << lfracs[c].second
							<< ", R(" << c << ") = " << rfracs[c].first << "/" << rfracs[c].second << "      ";
				}
				std::cout << '\n';
				current = weightedEntropy(lfracs, rfracs); 
				compare(current, minVal, min, d, it);
			}				
		}
		return min;
	}
	

	
	
public:

	TreeData(std::vector< std::vector<T> > dt, std::vector<U> out)
	: data(dt), outputs(out)
	{
		N = dt.size(); D = dt[0].size();
		findClasses();
		indicesTable();
		locatePnts();
		createSplits();
		
		for (std::size_t d = 0; d < D; ++d)
			for (std::size_t s = 0; s < indices[d].size(); ++s)
			{
				std::cout << "indices[" << d << "][" << s << "]: ";
				print< std::set<std::size_t> >(indices[d][s]);
			}
		
		std::cout << "\nInputs:\n";
		for (std::size_t n = 0; n < N; ++n)
			print< std::vector<double> >(data[n]);
		std::cout << "\nOutputs:\n";
		print< std::vector<U> >(outputs);
		std::cout << '\n';
	}
	
	
	double split()
	{
		std::pair<int, int> min = chooseSplit();
		int d = min.first, s = min.second;
		std::cout << "d = " << d << ", s = " << s << '\n';
		return splits[d][s];
	}
	
	
};

